8.포인터와 함수
==============
## 1. 함수의 의미
특정 기능을 수행하는 논리적 연산의 흐름을 묶은 단위로 함수 이름을 식별자라 함. 함수는 기능을 수행하는데 필요한 정보를 매개 변수의 형식으로 전달받아 그 결과를 각종 자료형으로 반환함.

cf> 사용자 함수 + sdk?


cf> C언어의 문법 중 함수만큼 경험을 요구하는 것도 없을 것 같다. 다른 문법들은 보통 이해하고 외우면 사용할 수 있지만, 함수는 기본 개념을 이해해야 하는 것은 물론이고, 여기에 직접 만들고 많이 사용해야만 비로소 좋은 함수를 만들 수 있다. - <열혈강의 다양한 예제로 완성하는 C포인터> 중

C언어 프로그램은 main() 함수에서 시작하여 함수 안에서 여러 함수를 호출한 후 main() 함수에서 종료됨. main() 함수보다 후에 선언 및 정의된 함수를 호출할 경우 컴파일러가 함수의 형태를 알 수 없어 컴파일 에러가 발생. 따라서 main() 함수 전에 함수를 선언 및 정의하거나 main()함수 전에 함수의 원형을 선언한 후 main()함수 후에 함수를 정의해야 함.


### 1.1. 인자(argument)와 매개 변수(parameter)


## 2. 주소를 인자 값으로 전달받는 함수
포인터 변수(n중 포인터, n차원 배열 포인터, 구조체 포인터, 공용체 포인터)를 매개 변수로 선언하여 주소를 인자 값으로 전달받을 수 있음.

## 2.1. 값에 의한 호출(Call by Value)과 참조에 의한 호출(Call by Reference)
값에 의한 호출은 변수의 값을 함수에 전달하는 방식이고 참조에 의한 호출은 주소를 함수에 전달하는 방식. 값에 의한 호출은 호출된 함수에서 복사된 메모리를 이용하지만 참조에 의한 호출은 호출된 함수에서 주소를 이용하여 원본 메모리에 접근 가능. 

## 3. 주소를 반환 값으로 전달하는 함수
함수의 반환값으로 어떤 자료형의 주소든 반환할 수 있지만 함수의 반환 값으로 자동 변수의 주소를 사용하면 안 됨. 함수가 종료하면 자동 변수는 소멸하기 때문에
## 재귀 함수
재귀함수는 자신의 함수를 직,간접적으로 다시 호출하는 함수. 

직접 호출

    void a()
    {
        a();
    }

간접 호출

    void b()
    {
        a();
    }    
    void a()
    {
        b();
    }

명령어의 반복을 선형적으로 처리할 때는 두 방법(반복문과 재귀 함수)에 별 차이점이 없지만 비선형적(재귀)인 명령어의 반복을 처리할 때는 반복문보다 주ㅐ귀 함수를 사용하는 것이 문제를 단순화하고 코드의 이해도 쉽게 한다.

자신의 함수를 호출한다고 해서 같은 상태 값(함수 스택 프레임)을 갖는 함수라고 생각하면 안 된다. 함수의 명령은 같지만, 함수의 호출 스택 프레임(함수를 호출할 때마다 유지되는 함수의 상태 집합)

cf> 스택과 스택 프레임
스택 선입후출 구조를 갖는 자료구조
스택 프레임이란 함수를 호출할 때마다 유지되는 함수의 상태 집합)

함수 포인터
함수 포인터란 함수의 시작 주소를 저장할 수 잇는 포인터 변수
모든 함수의 이름은 그 함수가 시작하는 주소.
함수포이터를 이요해 저장된 주소로 함수 호출 가능
함수 포인터의 이용 목적은 크게 두 가지 정도 첫 번째는 서로 다른 함수들을 같은 이름으로 호출하여 호출할 때마다 서로 다른 기능을 수행할 수 있도록 하고, 두 번째는 함수의 크기에 상관없이 함수의 주소 4바이트만을 저장함으로써 배열의 시작 주소를 저장하여 배열 요소에 접근하듯 함수의 기능을 사용할 수 있도록 함. 

> 함수 포인터로 함수 메모리에 접근해도 메모리는 상수로 변경 불가? 접근하면 실체는?
    void main(void);
    void (*p) (void);

## 함수 호출 규약(Calling Convention)
함수 호출 규약은 함수를 호출하는 방식에 대한 일종의 약속.
함수를 호출할 때 인자를 스택에 어떻게 쌓을 것인가와 함수 스택 프레임을 반환할 때 함수 호출자(Caller)와 함수 피호출자(Callee) 중 어디에서 반환할 것인지 작성. 함수 호출 규약에 따라 프로그램 수행 성능이 달라짐.
* __cdecl 방식은 함수에 인자를 전달할 때 오른쪽에서 왼쪽으로 전달하며 스택에 쌓아 올림. 또 함수 스택 프레임은 호출자에서 반환. C언어에서 함수에 어떤 호출 규약도 명시하지 않으면 --cdecl이 생략된 것.
* __stdcall 방식은 함수에 인자를 전달할 때 오른쪽에서 왼쪽으로 전달하며 스택에 쌓아 올림. 함수 스택 프레임은 피호출자에서 반환함.